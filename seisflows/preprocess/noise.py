#!/usr/bin/env python3
"""
The SeisFlows Preprocessing module is in charge of interacting with seismic
data (observed and synthetic). It should contain functionality to read and write
seismic data, apply preprocessing such as filtering, quantify misfit,
and write adjoint sources that are expected by the solver.
"""
import os
from glob import glob

from seisflows.preprocess.default import Default
from seisflows.tools import unix
from seisflows.tools.config import get_task_id
from seisflows.tools.specfem import read_stations


class Noise(Default):
    """
    Noise Preprocess
    ----------------
    Ambient Noise Adjoint Tomography (ANAT) preprocessing functions built ontop
    of the default preprocessing module. Additional functionalities allow for
    rotating and weighting horizontal components (N + E and R + T).

    Parameters
    ----------

    Paths
    -----

    ***
    """
    def __init__(self, path_specfem_data, **kwargs):
        """
        Preprocessing module parameters

        .. note::
            Paths and parameters listed here are shared with other modules and 
            so are not included in the class docstring.

        :type path_specfem_data: str
        :param path_specfem_data: path to SPECFEM DATA/ directory which must
            contain the CMTSOLUTION, STATIONS and Par_file files used for
            running SPECFEM
        """
        super().__init__()

        self.path.specfem_data = path_specfem_data

        # Internally used paramaters that should be filled in by `setup`
        self._stations = None

    def setup(self):
        """
        Setup procedures required for preprocessing module
        """
        super().setup()

        # Station dictionary containing locations to use for rotation
        self._stations = read_stations(
            os.path.join(self.path.specfem_data, "STATIONS")
        )

    def check(self):
        """ 
        Checks parameters and paths
        """
        super().check()

        # This is a redundant check on the DATA/STATIONS file (solver also
        # runs this check). This is required by noise workflows to determine
        # station rotation
        assert(self.path.specfem_data is not None and
               os.path.exists(self.path.specfem_data)), (
            f"`path_specfem_data` must exist and must point to directory " 
            f"containing SPECFEM input files"
        )
        assert(os.path.exists(
            os.path.join(self.path.specfem_data, "STATIONS"))), (
            f"DATA/STATIONS does not exist but is required by preprocessing"
        )

    def rotate_ne_traces_to_rt(self, source_name):
        """
        Rotates NN and EE synthetics generated by forward simulations to
        RR and TT component by calculating the azimuth between two stations.
        Used because the ANAT simulations are performed in N and E components,
        but EGF data is given in R and T components.

        :type source_name: str
        :param source_name: the name of the source to process
        """
        # Get organized by looking for available data
        source_name = source_name or self._source_names[get_task_id()]
        syn_dir = os.path.join(self.path.solver, source_name, "traces", "syn")

        # !!! Try to set this as a variable somewhere !!!
        traces_n = sorted(glob(os.path.join(syn_dir, "NN", "*")))
        traces_e = sorted(glob(os.path.join(syn_dir, "EE", "*")))

        # Define output directories for rotated waveforms
        traces_r = os.path.join(syn_dir, "RR")
        traces_t = os.path.join(syn_dir, "TT")
        for dir_ in [traces_r, traces_t]:
            unix.mkdir(dir_)

        # Determine the source station's latitude and longitude value
        src_lat = self._stations[source_name].latitude
        src_lon = self._stations[source_name].longitude

    def _rotate_ne_trace_to_rt(self, trace_n, trace_e, src_lat, src_lon):
        """
        Parallellizable function to rotate N and E trace to R and T based on
        source station and receiver station azimuth value

        .. note::
            We are assuming the structure of the filename is something
            like NN.SSS.CCc*
        """
        network, station, *_ = os.path.basename(trace_n).split(".")[:2]

        rcv_name = f"{network}_{station}"
        rcv_lat = self._stations[rcv_name].latitude
        rcv_lon = self._stations[rcv_name].longitude

