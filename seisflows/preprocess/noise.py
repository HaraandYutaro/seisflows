#!/usr/bin/env python3
"""
The SeisFlows Preprocessing module is in charge of interacting with seismic
data (observed and synthetic). It should contain functionality to read and write
seismic data, apply preprocessing such as filtering, quantify misfit,
and write adjoint sources that are expected by the solver.
"""
import os
import numpy as np
from concurrent.futures import ProcessPoolExecutor, wait
from glob import glob
from obspy.geodetics import gps2dist_azimuth

from seisflows.preprocess.default import Default
from seisflows.tools import unix
from seisflows.tools.config import get_task_id
from seisflows.tools.specfem import read_stations


class Noise(Default):
    """
    Noise Preprocess
    ----------------
    Ambient Noise Adjoint Tomography (ANAT) preprocessing functions built ontop
    of the default preprocessing module. Additional functionalities allow for
    rotating and weighting horizontal components (N + E and R + T).

    Parameters
    ----------

    Paths
    -----

    ***
    """
    def __init__(self, path_specfem_data, **kwargs):
        """
        Preprocessing module parameters

        .. note::
            Paths and parameters listed here are shared with other modules and 
            so are not included in the class docstring.

        :type path_specfem_data: str
        :param path_specfem_data: path to SPECFEM DATA/ directory which must
            contain the CMTSOLUTION, STATIONS and Par_file files used for
            running SPECFEM
        """
        super().__init__()

        self.path.specfem_data = path_specfem_data

        # Internally used paramaters that should be filled in by `setup`
        self._stations = None

    def setup(self):
        """
        Setup procedures required for preprocessing module
        """
        super().setup()

        # Station dictionary containing locations to use for rotation
        self._stations = read_stations(
            os.path.join(self.path.specfem_data, "STATIONS")
        )

    def check(self):
        """ 
        Checks parameters and paths
        """
        super().check()

        # This is a redundant check on the DATA/STATIONS file (solver also
        # runs this check). This is required by noise workflows to determine
        # station rotation
        assert(self.path.specfem_data is not None and
               os.path.exists(self.path.specfem_data)), (
            f"`path_specfem_data` must exist and must point to directory " 
            f"containing SPECFEM input files"
        )
        assert(os.path.exists(
            os.path.join(self.path.specfem_data, "STATIONS"))), (
            f"DATA/STATIONS does not exist but is required by preprocessing"
        )

    def rotate_ne_traces_to_rt(self, source_name, data_wildcard,
                               kernels="RR,TT"):
        """
        Rotates NN and EE synthetics generated by forward simulations to
        RR and TT component by calculating the azimuth between two stations.
        Used because the ANAT simulations are performed in N and E components,
        but EGF data is given in R and T components.

        :type source_name: str
        :param source_name: the name of the source to process
        :type kernels: str
        :param kernels: comma-separated list of kernels to consider writing
            files for. Available are 'TT' and 'RR'. To do both, set as
            'RR,TT' (order insensitive)
        """
        # Get a list of synthetic waveform files to pass to parallelized fx.
        source_name = source_name or self._source_names[get_task_id()]
        syn_dir = os.path.join(self.path.solver, source_name, "traces", "syn")

        # !!! Try to set this as a variable somewhere !!!
        traces_n = sorted(glob(os.path.join(syn_dir, "NN", "*")))
        traces_e = sorted(glob(os.path.join(syn_dir, "EE", "*")))

        # Create output directories for rotated waveforms
        for kernel in kernels.split(","):
            dir_ = os.path.join(syn_dir, kernel)
            unix.mkdir(dir_)

        # Rotate NE streams to RT in parallel
        with ProcessPoolExecutor(max_workers=unix.nproc()) as executor:
            futures = [
                executor.submit(self._rotate_ne_trace_to_rt, n, e, source_name,
                                kernels)
                for n, e in zip(traces_n, traces_e)
                ]
        # Simply wait until this task is completed because they are file writing
        wait(futures)

    def _rotate_ne_trace_to_rt(self, source_name, rcv_name, kernels="RR,TT"):
        """
        Parallellizable function to rotate N and E trace to R and T based on
        a single source station and receiver station pair and their
        respective azimuth values

        .. note::

            We are assuming the structure of the filename is something
            like NN.SSS.CCc*, which is standard from SPECFEM

        :type source_name: str
        :param source_name: the name of the source to process
        :type kernels: str
        :param kernels: comma-separated list of kernels to consider writing
            files for. Available are 'TT' and 'RR'. To do both, set as
            'RR,TT' (order insensitive)
        """
        traces = os.path.join(self.path.solver, source_name, "traces", "syn")
        fid = os.path.join(traces, "{kernel}", )

        # Determine the source station's latitude and longitude value
        src_lat = self._stations[source_name].latitude
        src_lon = self._stations[source_name].longitude

        # Determine the receiver station's name and coordinates
        rcv_lat = self._stations[rcv_name].latitude
        rcv_lon = self._stations[rcv_name].longitude

        # Calculate the azimuth and prime azimuth between the two stations
        # See Fig. 1 from Wang et al. (2019) for theta and theta' definitions
        _, az, baz = gps2dist_azimuth(lat1=src_lat, lon1=src_lon,
                                      lat2=rcv_lat, lon2=rcv_lon)
        # Theta != Theta' for a spherical Earth, but they will be close
        theta = np.deg2rad(az)
        theta_p = np.deg2rad((baz - 180) % 360)

        # Read in the N/E synthetic waveforms that need to be rotated
        # First letter represents the force direction, second is component
        st_nn = self.read(fid_nn, data_format=self.syn_data_format)
        st_ne = self.read(fid_ne, data_format=self.syn_data_format)
        st_ee = self.read(fid_ee, data_format=self.syn_data_format)
        st_en = self.read(fid_en, data_format=self.syn_data_format)

        if "TT" in kernels:
            st_t = st_n.copy()
            for tr_n, tr_e, tr_t in zip(st_n, st_e, st_t):
                tr_t.data = (+1 * np.cos(theta) * np.cos(theta_p) * u_ee
                             -1 * np.cos(theta) * np.sin(theta_p) * u_ne
                             -1 * np.sin(theta) * np.cos(theta_p) * u_en
                             +1 * np.sin(theta) * np.sin(theta_p) * u_nn
                             )
