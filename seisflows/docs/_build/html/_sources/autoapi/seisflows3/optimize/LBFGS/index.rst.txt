:py:mod:`seisflows3.optimize.LBFGS`
===================================

.. py:module:: seisflows3.optimize.LBFGS

.. autoapi-nested-parse::

   This is the custom class for an LBFGS optimization schema.
   It supercedes the `seisflows.optimize.base` class



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   seisflows3.optimize.LBFGS.LBFGS




Attributes
~~~~~~~~~~

.. autoapisummary::

   seisflows3.optimize.LBFGS.PAR
   seisflows3.optimize.LBFGS.PATH


.. py:data:: PAR
   

   

.. py:data:: PATH
   

   

.. py:class:: LBFGS

   Bases: :py:obj:`custom_import`\ (\ :py:obj:`'optimize'`\ , :py:obj:`'base'`\ )

   The Limited memory BFGS algorithm
   Calls upon seisflows.plugin.optimize.LBFGS to accomplish LBFGS algorithm

   Includes optional safeguards: periodic restarting and descent conditions.

   To conserve memory, most vectors are read from disk rather than passed
   from a calling routine.

   L-BFGS Variables:
       s: memory of model differences
       y: memory of gradient differences

   Optimization Variables:
       m: model
       f: objective function value
       g: gradient direction
       p: search direction

   Line Search Variables:
       x: list of step lenths from current line search
       f: correpsonding list of function values
       m: number of step lengths in current line search
       n: number of model updates in optimization problem
       gtg: dot product of gradient with itself
       gtp: dot product of gradient and search direction

   Status codes
       status > 0  : finished
       status == 0 : not finished
       status < 0  : failed

   .. py:attribute:: logger
      

      

   .. py:method:: required(self)
      :property:

      A hard definition of paths and parameters required by this class,
      alongside their necessity for the class and their string explanations.


   .. py:method:: check(self, validate=True)

      Checks parameters, paths, and dependencies


   .. py:method:: setup(self)

      Set up the LBFGS optimization schema


   .. py:method:: compute_direction(self)

      Call on the L-BFGS optimization machinery to compute a search
      direction using internally stored memory of previous gradients.
      The potential outcomes when computing direction with L-BFGS

      1. First iteration of L-BFGS optimization, search direction is defined
          as the inverse gradient
      2. L-BFGS internal iteration ticks over the maximum allowable number of
          iterations, force a restart condition, search direction is the
          inverse gradient
      3. New search direction vector is too far from previous direction,
          force a restart, search direction is inverse gradient
      4. New search direction is acceptably angled from previous,
          becomes the new search direction


   .. py:method:: restart(self)

      On top of base restart class, include a restart of the LBFGS internal
      memory and memmaps


   .. py:method:: update(self)

      Updates L-BFGS algorithm history

      .. note::
          Because models are large, and multiple iterations of models need to
          be stored in memory, previous models are stored as `memmaps`,
          which allow for access of small segments of large files on disk,
          without reading the entire file. Memmaps are array like objects.

      .. note::
          Notation for s and y taken from Liu & Nocedal 1989
          iterate notation: sk = x_k+1 - x_k and yk = g_k+1 - gk

      :rtype s: np.memmap
      :return s: memory of the model differences `m_new - m_old`
      :rtype y: np.memmap
      :return y: memory of the gradient differences `g_new - g_old`


   .. py:method:: apply(self, q, s=None, y=None)

      Applies L-BFGS inverse Hessian to given vector

      :type q: np.array
      :param q: gradient direction to apply L-BFGS to
      :type s: np.memmap
      :param s: memory of model differences
      :param s: memory of model differences
      :type y: np.memmap
      :param y: memory of gradient direction differences
      :rtype r: np.array
      :return r: new search direction from application of L-BFGS


   .. py:method:: check_status(self, g, r)

      Check the status of the apply() function, determine if restart necessary
      Return of False means restart, return of True means good to go.

      :type g: np.array
      :param g: current gradient direction
      :type r: np.array
      :param r: new gradient direction
      :rtype: bool
      :return: okay status based on status check (False==bad, True==good)



