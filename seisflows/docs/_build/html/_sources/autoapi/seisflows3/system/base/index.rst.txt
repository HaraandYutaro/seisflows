:py:mod:`seisflows3.system.base`
================================

.. py:module:: seisflows3.system.base

.. autoapi-nested-parse::

   The System module provides the basic core utilities for interaction with compute
   systems. The Base class must be overloaded by subclasses related to specific
   compute system types (cluster vs. workstation) and even specific HPCs.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   seisflows3.system.base.Base




Attributes
~~~~~~~~~~

.. autoapisummary::

   seisflows3.system.base.PAR
   seisflows3.system.base.PATH


.. py:data:: PAR
   

   

.. py:data:: PATH
   

   

.. py:class:: Base

   Abstract base class for the Systems module which controls interaction with
   compute systems such as HPC clusters.

   .. py:attribute:: logger
      

      

   .. py:method:: required(self)
      :property:

      A hard definition of paths and parameters required by this class,
      alongside their necessity for the class and their string explanations.


   .. py:method:: check(self, validate=True)

      Checks parameters and paths


   .. py:method:: setup(self)

      Create the SeisFlows3 directory structure in preparation for a
      SeisFlows3 workflow. Ensure that if any config information is left over
      from a previous workflow, that these files are not overwritten by
      the new workflow. Should be called by submit()

      .. note::
          This function is expected to create dirs: SCRATCH, SYSTEM, OUTPUT
          and the following log files: output, error

      .. note::
          Logger is configured here as all workflows, independent of system,
          will be calling setup()

      :rtype: tuple of str
      :return: (path to output log, path to error log)


   .. py:method:: submit(self)
      :abstractmethod:

      Main insertion point of SeisFlows3 onto the compute system.

      .. rubric::
          $ seisflows submit

      .. note::
          The expected behavior of the submit() function is to:
          1) run system setup, creating directory structure,
          2) execute workflow by submitting workflow.main()


   .. py:method:: run(self, classname, method, single=False, **kwargs)
      :abstractmethod:

      Runs a task multiple times in am embarassingly parallel fashion

      .. note::
          The expected behavior of the run() function is to: submit N jobs to
          the system in parallel. For example, in a simulation step, run()
          submits N jobs to the compute system where N is the number of
          events requiring an adjoint simulation.

      :type classname: str
      :param classname: the class to run
      :type method: str
      :param method: the method from the given `classname` to run
      :type single: bool
      :param single: run a single-process, non-parallel task, such as
          smoothing the gradient, which only needs to be run by once.
          This will change how the job array and the number of tasks is
          defined, such that the job is submitted as a single-core job to
          the system.
      :rtype: None
      :return: This function is not expected to return anything


   .. py:method:: taskid(self)
      :abstractmethod:

      Provides a unique identifier for each running task. This is
      compute system specific.

      :rtype: int
      :return: this function is expected to return a unique numerical
          identifier.


   .. py:method:: checkpoint(self, path, classname, method, kwargs)

      Writes the SeisFlows3 working environment to disk so that new tasks can
      be executed in a separate/new/restarted working environment.

      :type path: str
      :param path: path to save the checkpointed pickle files to
      :type classname: str
      :param classname: name of the class to save
      :type method: str
      :param method: the specific function to be checkpointed
      :type kwargs: dict
      :param kwargs: dictionary to pass to object saving



