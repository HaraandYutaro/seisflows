#!/usr/bin/env python3
"""
This is the subclass seisflows.solver.Specfem3D
This class provides utilities for the Seisflows solver interactions with
Specfem3D Cartesian. It inherits all attributes from seisflows.solver.Base,
and overwrites these functions to provide specified interaction with Specfem3D
"""
import os
from glob import glob

from seisflows.solver.specfem import Specfem
from seisflows.tools import unix
from seisflows.tools.utils import exists
from seisflows.tools.specfem import setpar, getpar


class Specfem3D(Specfem):
    """
    Python interface to Specfem3D Cartesian.
    """
    def __init__(self, source_prefix=None, **kwargs):
        """
        SPECFEM2D specific parameters

        :type source_prefix: str
        :param source_prefix: Prefix of SOURCE files in path SPECFEM_DATA.
        :type multiples: bool
        :param multiples: set an absorbing top-boundary condition
        """
        super().__init__(**kwargs)

        self.source_prefix = source_prefix or "CMTSOLUTION"

        # Define parameters based on material type
        if self.materials.upper() == "ACOUSTIC":
            self._parameters.append("vp")
        elif self.materials.upper() == "ELASTIC":
            self._parameters.append("vp")
            self._parameters.append("vs")

        self._acceptable_source_prefixes = ["CMTSOLUTION", "FORCESOLUTION"]

    def data_wildcard(self, comp="?"):
        """
        Returns a wildcard identifier for synthetic data

        :rtype: str
        :return: wildcard identifier for channels
        """
        if self.data_format.upper() == "SU":
            return f"*_d?_SU"
        elif self.data_format.upper() == "ASCII":
            return f"*.?X{comp}.sem?"

    @property
    def model_databases(self):
        """
        The location of databases for model outputs, usually
        OUTPUT_FILES/DATABASES_MPI. Value is grabbed from the Par_file
        """
        local_path = getpar(key="LOCAL_PATH",
                            file=os.path.join(self.cwd, "DATA", "Par_file"))[1]
        return local_path

    @property
    def kernel_databases(self):
        """
        The location of databases for kernel outputs, usually the same as
        'model_databases'
        """
        return self.model_databases

    def eval_func(self, path, preprocess=None):
        """
        Performs forward simulations and evaluates the misfit function using
        the preprocess module. Overrides to add a data renaming call

        .. note::
            This task should be run in parallel by system.run()

        :type path: str
        :param path: directory from which model is imported and where residuals
            will be exported
        :type write_residuals: bool
        :param write_residuals: calculate and export residuals        """
        super().eval_func(path=path, preprocess=preprocess)

        # Work around SPECFEM3D conflicting name conventions of SU data
        self._rename_data()

    def forward_simulation(self, output_seismograms=False):
        """
        Calls SPECFEM3D forward solver, exports solver outputs to traces dir

        :type output_seismograms: str
        :param output_seismograms: path to export traces to after completion of
            simulation expected values are either 'traces/obs' for 'observation'
            data (i.e., synthetics generated by the TRUE model), or
            'traces/syn', for synthetics generated during function evaluations.
            If False, will leave seismograms in OUTPUT_FILES/s
        """
        unix.cd(self.cwd)

        # Set parameters and run forward simulation
        setpar(key="SIMULATION_TYPE", val="1", file="DATA/Par_file")
        setpar(key="SAVE_FORWARD", val=".true.", file="DATA/Par_file")

        if self.attenuation:
            setpar(key="ATTENUATION", val=".true.", file="DATA/Par_file")
        else:
            setpar(key="ATTENUATION", val=".false`.", file="DATA/Par_file")

        self._call_solver(executable="bin/xgenerate_databases",
                          output="fwd_mesher.log")
        self._call_solver(executable="bin/xmeshfem3D", output="fwd_solver.log")

        # Find and move output traces, by default to synthetic traces dir
        if output_seismograms:
            unix.mv(
                src=glob(os.path.join("OUTPUT_FILES", self.data_wildcard())),
                dst=output_seismograms
            )

    def adjoint_simulation(self):
        """
        Calls SPECFEM3D adjoint solver, creates the `SEM` folder with adjoint
        traces which is required by the adjoint solver
        """
        unix.cd(self.cwd)

        setpar(key="SIMULATION_TYPE", val="3", file="DATA/Par_file")
        setpar(key="SAVE_FORWARD", val=".false.", file="DATA/Par_file")

        # Attenuation should always be OFF during adjoint simulations, else
        # you will get a floating point error
        setpar(key="ATTENUATION", val=".false.", file="DATA/Par_file")

        unix.rm("SEM")
        unix.ln("traces/adj", "SEM")

        self._call_solver(executable="bin/xspecfem3D", output="adj_solver.log")

    def _initialize_adjoint_traces(self):
        """
        Setup utility: Creates the "adjoint traces" expected by SPECFEM

        .. note::
            Adjoint traces are initialized by writing zeros for all channels.
            Channels actually in use during an inversion or migration will be
            overwritten with nonzero values later on.
        """
        # Initialize adjoint traces as zeroes for all data_filenames
        # write to `traces/adj`
        super()._initialize_adjoint_traces()

        # Rename data to work around Specfem naming convetions
        self._rename_data()

        # Workaround for Specfem3D's requirement that all components exist,
        # even ones not in use as adjoint traces
        if self.data_format.upper() == "SU":
            unix.cd(os.path.join(self.cwd, "traces", "adj"))

            for iproc in range(self.nproc):
                for channel in ["x", "y", "z"]:
                    dst = f"{iproc:d}_d{channel}_SU.adj"
                    if not os.path.exists(dst):
                        src = f"{iproc:d}_d{self.components[0]}_SU.adj"
                        unix.cp(src, dst)

    def _rename_data(self):
        """
        Works around conflicting data filename conventions

        Specfem3D's uses different name conventions for regular traces
        and 'adjoint' traces
        """
        if self.data_format.upper() == "SU":
            files = glob(os.path.join(self.cwd, "traces", "adj", "*SU"))
            unix.rename(old='_SU', new='_SU.adj', names=files)
