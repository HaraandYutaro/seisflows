:py:mod:`seisflows3.workflow.base`
==================================

.. py:module:: seisflows3.workflow.base

.. autoapi-nested-parse::

   This is the Base class for seisflows.workflow.
   It contains mandatory functions that must be called by subclasses



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   seisflows3.workflow.base.Base




Attributes
~~~~~~~~~~

.. autoapisummary::

   seisflows3.workflow.base.PAR
   seisflows3.workflow.base.PATH


.. py:data:: PAR
   

   

.. py:data:: PATH
   

   

.. py:class:: Base

   Workflow abstract base class

   .. py:attribute:: logger
      

      

   .. py:method:: required(self)
      :property:

      A hard definition of paths and parameters required by this class,
      alongside their necessity for the class and their string explanations.


   .. py:method:: check(self, validate=True)

      Checks parameters and paths. Must be implemented by sub-class


   .. py:method:: main(self, return_flow=False)

      Execution of a workflow is equal to stepping through workflow.main()

      An example main() script is provided below which details the requisite
      parts. This function will NOT execute as it is written in pseudocode.

      :type return_flow: bool
      :param return_flow: for CLI tool, simply returns the flow function
          rather than running the workflow. Used for print statements etc.


   .. py:method:: check_stop_resume_cond(self, flow)

      Chek the stop after and resume from conditions

      Allow the main() function to resume a workflow from a given flow
      argument, or stop the workflow after a given argument. In the event
      that a previous workflow errored, or if the User had previously
      stopped a workflow to look at results and they want to pick up where
      they left off.

      Late check: Exits the workflow if RESUME_FROM or STOP_AFTER arguments
      do not match any of the given flow arguments.

      :type flow: tuple of functions
      :param flow: an ordered list of functions that will be
      :rtype: tuple of int
      :return: (start, stop) indices of the `flow` input dictating where the
          list should be begun and ended. If RESUME_FROM and STOP_AFTER
          conditions are NOT given by the user, start and stop will be 0 and
          -1 respectively, meaning we should execute the ENTIRE list


   .. py:method:: checkpoint()
      :staticmethod:

      Writes information to disk so workflow can be resumed following a break



