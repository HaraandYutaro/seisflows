:py:mod:`seisflows3.optimize.NLCG`
==================================

.. py:module:: seisflows3.optimize.NLCG

.. autoapi-nested-parse::

   This is the custom class for an NLCG optimization schema.
   It supercedes the `seisflows.optimize.base` class



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   seisflows3.optimize.NLCG.NLCG



Functions
~~~~~~~~~

.. autoapisummary::

   seisflows3.optimize.NLCG.fletcher_reeves
   seisflows3.optimize.NLCG.pollak_ribere
   seisflows3.optimize.NLCG.check_conjugacy
   seisflows3.optimize.NLCG.check_descent



Attributes
~~~~~~~~~~

.. autoapisummary::

   seisflows3.optimize.NLCG.PAR
   seisflows3.optimize.NLCG.PATH


.. py:data:: PAR
   

   

.. py:data:: PATH
   

   

.. py:class:: NLCG

   Bases: :py:obj:`custom_import`\ (\ :py:obj:`'optimize'`\ , :py:obj:`'base'`\ )

   Nonlinear conjugate gradient method

   Optimization Variables:
       m: model
       f: objective function value
       g: gradient direction
       p: search direction

   Line Search Variables:
       x: list of step lenths from current line search
       f: correpsonding list of function values
       m: number of step lengths in current line search
       n: number of model updates in optimization problem
       gtg: dot product of gradient with itself
       gtp: dot product of gradient and search direction

   Status codes
       status > 0  : finished
       status == 0 : not finished
       status < 0  : failed

   .. py:attribute:: logger
      

      

   .. py:method:: required(self)
      :property:

      A hard definition of paths and parameters required by this class,
      alongside their necessity for the class and their string explanations.


   .. py:method:: check(self, validate=True)

      Checks parameters, paths, and dependencies


   .. py:method:: compute_direction(self)

      Compute search direction using the Nonlinear Conjugate Gradient method
      The potential outcomes when computing direction with NLCG

      1. First iteration of an NLCG optimization, search direction is
          the inverse gradient
      2. NLCG internal iteration ticks over the maximum allowable number of
          iterations, force a restart condition, search direction is the
          inverse gradient
      3. New NLCG search direction does not have conjugacy with previous
          search direction, force restart, inverse gradient search direction
      4. New NLCG search direction is not a descent direction,
          force restart, inverse gradient search direction
      5. New NLCG search direction has conjugacy and is a descent direction
          and is set as the new search direction.


   .. py:method:: restart(self)

      Overwrite the Base restart class and include a restart of the NLCG



.. py:function:: fletcher_reeves(g_new, g_old, precond=lambda x: x)

   One method for calculating beta in the NLCG Algorithm from
   Fletcher & Reeves, 1964

   :type g_new: np.array
   :param g_new: new search direction
   :type g_old: np.array
   :param g_old: old search direction
   :type precond: function
   :param precond: preconditioner, defaults to simple return
   :rtype: float
   :return: beta, the scale factor to apply to the old search direction to
       determine the new search direction


.. py:function:: pollak_ribere(g_new, g_old, precond=lambda x: x)

   One method for calculating beta in the NLCG Algorithm from
   Polak & Ribiere, 1969

   :type g_new: np.array
   :param g_new: new search direction
   :type g_old: np.array
   :param g_old: old search direction
   :type precond: function
   :param precond: preconditioner, defaults to simple return
   :rtype: float
   :return: beta, the scale factor to apply to the old search direction to
       determine the new search direction


.. py:function:: check_conjugacy(g_new, g_old)

   Check for conjugacy between two vectors

   :type g_new: np.array
   :param g_new: new search direction
   :type g_old: np.array
   :param g_old: old search direction
   :rtype: float
   :return: an element that proves conjugacy


.. py:function:: check_descent(p_new, g_new)

   Ensure that the search direction is descending

   :type p_new: np.array
   :param p_new: search direction
   :type g_new: np.array
   :param g_new: gradient direction
   :rtype: float
   :return: the angle between search direction and gradient direction, should
       be negative to ensure descent


