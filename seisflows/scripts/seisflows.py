#!/usr/bin/env python
"""
The main entry point to the SeisFlows package. A high-level command line tool 
that facilitates interface with the underlying SeisFlows environment, package.
"""
import os
import sys
import inspect
import warnings
import argparse
import subprocess
from glob import glob
from textwrap import wrap
from seisflows.tools import unix, tools
from seisflows.tools.tools import loadyaml, loadpy, parse_null
from seisflows.config import (init_seisflows, tilde_expand, Dict, custom_import,
                              NAMES, PACKAGES, ROOT_DIR)


def sfparser():
    """
    Get User defined arguments, or assign defaults. Make use of subparsers to
    get individual help statements for each of the main functions.

    :rtype: argparse.ArgumentParser()
    :return: User defined or default arguments
    """
    class SubcommandHelpFormatter(argparse.RawDescriptionHelpFormatter):
        """
        Override the help statement to NOT print out available subcommands

        https://stackoverflow.com/questions/13423540/
                              argparse-subparser-hide-metavar-in-command-listing
        """
        def _format_action(self, action):
            parts = super()._format_action(action)
            if action.nargs == argparse.PARSER:
                parts = "\n".join(parts.split("\n")[1:])
            return parts

    parser = argparse.ArgumentParser(
        formatter_class=SubcommandHelpFormatter,
        description=f"{'='*80}\n\n"
                    f"{'SeisFlows: Waveform Inversion Package':^80}\n\n"
                    f"{'='*80}",
        epilog="'seisflows [command] -h' for more detailed descriptions "
               "of each command.",
    )

    # Optional parameters
    parser.add_argument("-w", "--workdir", nargs="?", default=os.getcwd(),
                        help="The SeisFlows working directory, default: cwd")
    parser.add_argument("-p", "--parameter_file", nargs="?",
                        default="parameters.yaml",
                        help="Parameters file, default: 'parameters.yaml'")
    parser.add_argument("--path_file", nargs="?", default="paths.py",
                        help="Legacy path file, default: 'paths.py'")

    # Initiate a sub parser to provide nested help functions and sub commands
    subparser = parser.add_subparsers(
        title="command",
        description="Available SeisFlows arguments and their intended usages",
        dest="command",
    )
    # The following subparsers constitute the available SeisFlows commands
    # =========================================================================
    setup = subparser.add_parser(
        "setup", help="Setup working directory from scratch",
        description="""In the specified working directory, copy template 
        parameter file containing only module choices, and symlink source code 
        for both the base and super repositories for easy edit access. If a 
        parameter file matching the provided name exists in the working 
        directory, a prompt will appear asking the user if they want to 
        overwrite."""
    )
    setup.add_argument("-s", "--symlink", action="store_true",
                       help="symlink source code into the working directory")
    setup.add_argument("-o", "--overwrite", action="store_true",
                       help="automatically overwrites existing parameter file")
    # =========================================================================
    modules = subparser.add_parser(
        "modules", help="Print available module names",
        description="""Lists out the available module names that can be used to 
        fill in the template parameter file generated by 'setup'. Identifies 
        potential module names by searching for '.py' extension files in the 
        available packages, while ignoring any private files such as 
        __init__.py."""
    )
    modules.add_argument("-n", "--name", nargs="?", type=str,
                         help="Optional name to specify individual module")
    modules.add_argument("-p", "--package", nargs="?", type=str,
                         help="Optional name to specify individual package")
    # =========================================================================
    subparser.add_parser(
        "configure", help="Fill parameter file with defaults",
        description="""SeisFlows parameter files will vary depending on 
        chosen modules and their respective required parameters. This function 
        will dynamically traverse the source code and generate a template 
        parameter file based on module choices. The resulting file incldues 
        docstrings and type hints for each parameter. Optional parameters will 
        be set with default values and required parameters and paths will be 
        marked appropriately. Required parameters must be set before a workflow
        can be submitted."""
    )
    subparser.add_parser(
        "init", help="Initiate working environment",
        description="""Establish a SeisFlows working environment but don't 
        submit the workflow to the system and do not perform variable  error 
        checking. Saves the initial state as pickle files to allow for active 
        environment inspection prior to running 'submit'. Useful for debugging, 
        development and code exploration."""
    )
    # =========================================================================
    submit = subparser.add_parser(
        "submit", help="Submit initial workflow to system",
        description="""The main SeisFlows execution command. Submit a SeisFlows 
        workflow to the chosen system, equal to executing 
        seisflows.workflow.main(). This function will create and fill the 
        working directory with required paths, perform path and parameter 
        error checking, and establish the active working environment before
        executing the workflow."""
    )
    submit.add_argument("-p", "--precheck_off", action="store_true",
                        help="Turn off the default parameter precheck")
    submit.add_argument("-s", "--stop_after", default=None, type=str,
                        help="Optional override of the 'STOP_AFTER' parameter")
    # =========================================================================
    resume = subparser.add_parser(
        "resume", help="Re-submit previous workflow to system",
        description="""Resume a previously submitted workflow. Used when 
        an active environment exists in the working directory, and must be 
        submitted to the system again."""
    )
    resume.add_argument("-p", "--precheck_off", action="store_true",
                        help="Turn off the default parameter precheck")
    resume.add_argument("-r", "--resume_from", default=None, type=str,
                        help="Optional override of the 'RESUME_FROM' parameter")
    resume.add_argument("-s", "--stop_after", default=None, type=str,
                        help="Optional override of the 'STOP_AFTER' parameter")
    # =========================================================================
    subparser.add_parser(
        "clean", help="Remove active working environment",
        description="""Delete all SeisFlows related files in the working 
        directory, except for the parameter file."""
    )
    # =========================================================================
    par = subparser.add_parser(
        "par", help="View and edit parameter file",
        description="""Directly edit values in the parameter file by providing
        the parameter and corresponding value. If no value is provided, will 
        simply print out the current value of the given parameter. Works also
        with path names."""
    )
    par.add_argument("parameter", nargs="?", help="Parameter to edit or view")
    par.add_argument("value", nargs="?", default=None,
                     help="Optional value to set parameter to.")
    # =========================================================================
    check = subparser.add_parser(
        "check",  formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""
Check parameters, state, or values of an active environment

    model     check the min/max values of currently active models tracked by
              optimize. 'seisflows check model [name]' to check specific model.
    iter      Check current interation and step count of workflow
    src       List source names and respective internal indices
    isrc      Check source name for corresponding index
                """,
        help="Check state of an active environment")

    check.add_argument("choice", type=str,  nargs="?",
                       help="Parameter, state, or value to check")
    check.add_argument("args", type=str,  nargs="*",
                       help="Generic arguments passed to check functions")
    # =========================================================================
    subparser.add_parser("convert", help="Convert model file format", )
    subparser.add_parser("reset", help="Reset underlying machinery")
    # =========================================================================
    inspect = subparser.add_parser(
        "inspect", help="View inheritenace and ownership",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""\
Display the order of inheritance for one or all of the SeisFlows modules.
e.g. 'seisflows inspect solver'

  OR

Determine method ownership for a given function, listing the exact package and 
module that defined it. This functionality occurs if both 'name' and 'func' are 
provided as positional arguments.
e.g. 'seisflows inspect solver eval_func'
"""
    )
    inspect.add_argument("name", type=str,  nargs="?", default=None,
                         help="Optional name of SeisFlows module to inspect")
    inspect.add_argument("func", type=str,  nargs="?", default=None,
                         help="Optional method name to inspect ownership for")
    # =========================================================================
    subparser.add_parser(
        "debug", help="Start interactive debug environment",
        description="""Starts an IPython debugging environment and loads an
        active SeisFlows working state, as well as distributing the SeisFlows
        module namespace. Allows exploration of the active state, as well as
        manually control of the workflow. Useful for recovery from unexpected
        workflow crashes. State changes will not be saved automatically. Type
        'workflow.checkpoint()' in the debug environment to save any changes
        made during debugging.
        """)
    # =========================================================================
    edit = subparser.add_parser(
        "edit", help="Open source code file in text editor",
        description="""Directly edit source code files in your favorite 
        terminal text editor. Simply a shortcut to avoid having to root around
        in the repository. Any saved edits will directly affect the SeisFlows
        source code and any code errors may lead to failure of the package;
        e.g. 'seisflows edit solver base'"""
    )
    edit.add_argument("name", type=str,  nargs="?", default=None,
                      help="Name of module to search for source file in")
    edit.add_argument("module", type=str,  nargs="?", default=None,
                      help="Name of specific module file to open, extension "
                           "not required")
    edit.add_argument("-e", "--editor", type=str,  nargs="?", default=None,
                      help="Chosen text editor, defaults to $EDITOR env var")
    edit.add_argument("-d", "--dont_open", action="store_true",
                      help="Dont open the text editor, just list full pathname")
    # =========================================================================
    subparser_dict = {"check": check, "par": par, "inspect": inspect,
                      "edit": edit}
    if parser.parse_args().command in subparser_dict:
        return parser, subparser_dict[parser.parse_args().command]
    else:
        return parser, None


class SeisFlows:
    """
    The main entry point to the SeisFlows package. Responsible for setting up
    or re-creating a SeisFlows enviornment, (re-)submitting workflows, or
    inspecting, manipulating or viewing a live environment via command line
    arguments.

    .. note::
        Almost every modules requires loading of other modules, i.e. to run
        any checks we must load the entire SeisFlows environment, which is slow
        but provides the most flexibility when accessing internal information
    """
    def __init__(self):
        """
        Parse user-defined arguments, call internal method with given arguments
        """
        self._parser, self._subparser = sfparser()
        self._paths = None
        self._parameters = None

        # Print out the help statement if no command is given
        if len(sys.argv) == 1:
            self._parser.print_help()
            sys.exit(0)

        self._args = self._parser.parse_args()

        # Throw in all arguments as kwargs and let the function sort it out
        getattr(self, self._args.command)(**vars(self._args))

    @property
    def _public_methods(self):
        """
        Return a list of all public methods within this class.

        .. warning::
            Only methods that can be called via the command line should be
            public, all other methods and attributes should be private.
        """
        return [_ for _ in dir(self) if not _.startswith("_")]

    def _register(self, precheck=True):
        """
        Load the paths and parameters from file into sys modules, set the
        default parameters if they are missing from the file, and expand all
        paths to absolute pathnames.

        :type precheck: bool
        :param precheck: print out a few key parameters and require user-input
            before allowing workflow to be submitted. This is usually run before
            submit and resume, to prevent job submission without evaluation.
        """
        # Check if the filepaths exist
        if not os.path.exists(self._args.parameter_file):
            sys.exit(f"\n\tSeisFlows parameter file not found: "
                     f"{self._args.parameter_file}\n")

        # Register parameters from the parameter file
        if self._args.parameter_file.endswith(".yaml"):
            parameters = loadyaml(self._args.parameter_file)
            try:
                paths = parameters["PATHS"]
                parameters.pop("PATHS")
            except KeyError:
                paths = {}
        #  Allow for legacy .py parameter file naming
        elif self._args.parameter_file.endwith(".py"):
            warnings.warn(".py parameter and path files are deprecated in "
                          "favor of a .yaml parameter file. Please consider "
                          "switching as the use of legacy .py files may have "
                          "unintended consequences at runtime",
                          DeprecationWarning)

            if not os.path.exists(self._args.paths_file):
                sys.exit(f"\n\tLegacy parameter file requires corresponding "
                         f"path file\n")
            parameters = loadpy(self._args.parameter_file)
            paths = loadpy(self._args.path_file)
        else:
            raise TypeError(f"Unknown file format for "
                            f"{self._args.parameter_file}, file must be "
                            f"'.yaml' (preferred) or '.py' (legacy)")

        # WORKDIR needs to be set here as it's expected by most modules
        if "WORKDIR" not in paths:
            paths["WORKDIR"] = self._args.workdir

        # For submit() and resume(), provide a dialogue to stdout requiring a
        # visual pre-check of parameters before submitting workflow
        if precheck and parameters["PRECHECK"]:
            print("\n\tSEISFLOWS PARAMETER CHECK"
                  "\n\t=========================\n")
            for par in parameters["PRECHECK"]:
                par = par.upper()
                try:
                    print(f"\t{par}: {parameters[par]}")
                except KeyError:
                    print(f"\t{par}: !!! PARAMETER NOT FOUND !!!")
            print("\n")
            check = input("\tContinue? (y/[n]): ")
            if check != "y":
                sys.exit(-1)

        # Register parameters to sys, ensure they meet standards of the package
        # parameters = parse_null(parameters)
        sys.modules["seisflows_parameters"] = Dict(parameters)

        # Register paths to sys, expand to relative paths to absolute, drop null
        paths = tilde_expand(parse_null(paths))
        paths = {key: os.path.abspath(path) for key, path in paths.items()}
        sys.modules["seisflows_paths"] = Dict(paths)

        self._paths = paths
        self._parameters = parameters

    def _load_modules(self):
        """
        A function to load and check each of the SeisFlows modules,
        re-initiating the SeisFlows environment. All modules are reliant on one
        another so any access to SeisFlows requires loading everything
        simultaneously.
        """
        # Working directory should already have been created by submit()
        unix.cd(self._args.workdir)

        # Reload objects from Pickle files
        for name in NAMES:
            fullfile = os.path.join(self._args.workdir, "output",
                                    f"seisflows_{name}.p")

            if not os.path.exists(fullfile):
                sys.exit(f"\n\tNot a SeisFlows working directory, state file "
                         f"not found:\n\t{fullfile}\n")

            sys.modules[f"seisflows_{name}"] = tools.loadobj(fullfile)

        # Check parameters so that default values are present
        for name in NAMES:
            sys.modules[f"seisflows_{name}"].check()

    def modules(self, name=None, package=None, **kwargs):
        """
        Search for the names of available modules in SeisFlows name space.
        This simple function checks for files with a '.py' extension inside
        each of the sub-directories, ignoring private files like __init__.py.

        :type name: str
        :param name: specify an specific module name to list
        :type package: str
        :param package: specify an indivdual package to search
        """
        REPO_DIR = os.path.abspath(os.path.join(ROOT_DIR, ".."))

        for NAME in NAMES:
            if name is not None and name != NAME:
                continue
            print(f"\n{NAME.upper()}")
            for PACKAGE in PACKAGES:
                if package is not None and package != PACKAGE:
                    continue
                print(f" * {PACKAGE}")
                mod_dir = os.path.join(REPO_DIR, PACKAGE, NAME)
                for pyfile in sorted(glob(os.path.join(mod_dir, "*.py"))):
                    stripped_pyfile = os.path.basename(pyfile)
                    stripped_pyfile = os.path.splitext(stripped_pyfile)[0]
                    if not stripped_pyfile.startswith("_"):
                        print(f"    {os.path.basename(stripped_pyfile)}")

    def setup(self, symlink=False, overwrite=False, **kwargs):
        """
        Initiate a SeisFlows working directory from scratch; establish a
        template parameter file and symlink the source code for easy access

        :type symlink: bool
        :param symlink: flag to turn on source code symlinking
        :type overwrite: bool
        :param overwrite: flag to force parameter file overwriting
        """
        PAR_FILE =  os.path.join(ROOT_DIR, "templates", "parameters.yaml")
        REPO_DIR = os.path.abspath(os.path.join(ROOT_DIR, ".."))

        if os.path.exists(self._args.parameter_file):
            if not overwrite:
                print(f"\n\tParameter file '{self._args.parameter_file}' "
                      f"already exists\n")
                check = input(f"\tOverwrite with blank file? (y/[n]): ")
            else:
                check = "y"

            if check == "y":
                unix.rm(self._args.parameter_file)
        unix.cp(PAR_FILE, self._args.workdir)

        # Symlink the source code for easy access to repo
        if symlink:
            src_code = os.path.join(self._args.workdir, "source_code")
            if not os.path.exists(src_code):
                unix.mkdir(src_code)
                for package in PACKAGES:
                    unix.ln(os.path.join(REPO_DIR, package), src_code)

    def configure(self, **kwargs):
        """
        Dynamically generate the parameter file by writing out docstrings and
        default values for each of the SeisFlows module parameters.
        This function writes files manually, consistent with the .yaml format.
        """
        self._register(precheck=False)

        def write_header(f, paths_or_parameters, name=""):
            """Re-usable function to write docstring comments"""
            # Some aesthetically pleasing dividers to separate sections
            TOP = (f"\n# {'=' * 78}\n#\n"
                   f"# {name.upper():^78}\n# {'-' * len(name):^78}\n"
                   f"#\n")
            BOT = f"\n# {'=' * 78}\n"
            TAB = "    "  # 4spacegang

            f.write(TOP)
            for key, attrs in paths_or_parameters.items():
                if "type" in attrs:
                    f.write(f"# {key} ({attrs['type']}):\n")
                else:
                    f.write(f"# {key}:\n")
                # Ensure that total line width is no more than 80 characters
                docstrs = wrap(attrs["docstr"], width=77 - len(TAB),
                               break_long_words=False)
                for line, docstr in enumerate(docstrs):
                    f.write(f"#{TAB}{docstr}\n")
            f.write(BOT)

        def write_paths_parameters(f, paths_or_parameters, indent=""):
            """Re-usable function to write paths or parameters in yaml format"""
            TAB = "    "
            for key, attrs in paths_or_parameters.items():
                # Lists need to be treated differently in yaml format
                if isinstance(attrs["default"], list):
                    f.write(f"{key}:\n")
                    for val in attrs["default"]:
                        f.write(f"{TAB}- {val}\n")
                else:
                    # Yaml saves NoneType values as 'null'
                    if attrs["default"] is None:
                        attrs["default"] = "null"
                    f.write(f"{indent}{key}: {attrs['default']}\n")

        # Establish the paths and parameters provided by the user
        if not self._args.parameter_file.endswith(".yaml"):
            sys.exit(f"\n\tseisflows configure only applicable to .yaml "
                     f"parameter files\n")

        # Need to attempt importing all modules before we access any of them
        for name in NAMES:
            sys.modules[f"seisflows_{name}"] = custom_import(name)()

        # System defines foundational directory structure required by other
        # modules. Don't validate the parameters because they aren't yet set
        sys.modules["seisflows_system"].required.validate(paths=True,
                                                          parameters=False)

        # If writing to parameter file fails for any reason, the file will be
        # mangled, create a temporary copy that can be re-instated upon failure
        temp_par_file = f".{self._args.parameter_file}"
        unix.cp(self._args.parameter_file, temp_par_file)
        try:
            # Paths are collected for each but written at the end
            seisflows_paths = {}
            with open(self._args.parameter_file, "a") as f:
                for name in NAMES:
                    req = sys.modules[f"seisflows_{name}"].required
                    seisflows_paths.update(req.paths)
                    write_header(f, req.parameters, name)
                    write_paths_parameters(f, req.parameters)
                # Write the paths in the same format as parameters
                write_header(f, seisflows_paths, name="PATHS")
                f.write("PATHS:\n")
                write_paths_parameters(f, seisflows_paths, indent="    ")
        except Exception as e:
            # General error catch as anything can happen here
            unix.rm(self._args.parameter_file)
            unix.cp(temp_par_file, self._args.parameter_file)
            sys.exit(f"\n\tseisflows configure failed with exception:\n\t{e}\n")
        else:
            unix.rm(temp_par_file)

    def init(self, **kwargs):
        """
        Establish a SeisFlows working environment without error checking.
        Save the initial state as pickle files for environment inspection.
        Useful for debugging, development and code exploration purposes.
        """
        self._register(precheck=False)

        unix.mkdir(self._args.workdir)
        unix.cd(self._args.workdir)

        init_seisflows()
        workflow = sys.modules["seisflows_workflow"]
        workflow.checkpoint()

    def submit(self, stop_after=None, precheck_off=False, **kwargs):
        """
        Main SeisFlows execution command. Submit the SeisFlows workflow to
        the chosen system, and execute seisflows.workflow.main(). Will create
        the working directory and any required paths and ensure that all
        required paths exist.

        :type stop_after: str
        :param stop_after: allow the function to overwrite the 'STOP_AFTER'
            parameter in the parameter file, which dictates how far the workflow
            will proceed until stopping. Must match flow function names in
            workflow.main()
        :type precheck_off: bool
        :param precheck_off: if True, turns off the parameter precheck and
            simply submits the workflow
        """
        if stop_after is not None:
            self.par(parameter="STOP_AFTER", value=stop_after)

        self._register(precheck=not precheck_off)

        # A list of paths that need to exist if provided by user
        REQ_PATHS = ["SPECFEM_BIN", "SPECFEM_DATA", "MODEL_INIT", "MODEL_TRUE",
                     "DATA", "LOCAL", "MASK"]

        # Check that all required paths exist before submitting workflow
        paths_dont_exist = []
        for key in REQ_PATHS:
            if key in self._paths and not os.path.exists(self._paths[key]):
                paths_dont_exist.append(self._paths[key])
        if paths_dont_exist:
            print("\nThe following paths do not exist:\n")
            for path_ in paths_dont_exist:
                print(f"\t{path_}")
            print("\n")
            sys.exit()

        unix.mkdir(self._args.workdir)
        unix.cd(self._args.workdir)

        # Submit workflow.main() to the system
        init_seisflows()
        workflow = sys.modules["seisflows_workflow"]
        system = sys.modules["seisflows_system"]
        system.submit(workflow)

    def clean(self, **kwargs):
        """
        Clean the SeisFlows working directory except for the parameter file.
        """
        check = input("\n\tThis will remove all workflow objects, leaving only "
                      "the parameter file.\n\tAre you sure you want to clean? "
                      "(y/[n]): ")

        if check == "y":
            for fid in glob(os.path.join(self._args.workdir, "output*")):
                unix.rm(fid)
            for fid in glob(os.path.join(self._args.workdir, "*log*")):
                unix.rm(fid)
            unix.rm(os.path.join(self._args.workdir, "scratch"))

    def resume(self, stop_after=None, resume_from=None, precheck_off=False,
               **kwargs):
        """
        Resume a previously started workflow by loading the module pickle files
        and submitting the workflow from where it left off.
                :type stop_after: str
        :param stop_after: allow the function to overwrite the 'STOP_AFTER'
            parameter in the parameter file, which dictates how far the workflow
            will proceed until stopping. Must match flow function names in
            workflow.main()
        :type resume_from: str
        :param resume_from: allow the function to overwrite the 'RESUME_FROM'
            parameter in the parameter file, which dictates which function the
            workflow starts from, must match the flow functions given in
            workflow.main()
        :type precheck_off: bool
        :param precheck_off: if True, turns off the parameter precheck and
            simply submits the workflow
        """
        if stop_after is not None:
            self.par(parameter="STOP_AFTER", value=stop_after)
        if resume_from is not None:
            self.par(parameter="RESUME_FROM", value=resume_from)

        import ipdb;ipdb.set_trace()

        self._register(precheck=not precheck_off)
        self._load_modules()

        workflow = sys.modules["seisflows_workflow"]
        system = sys.modules["seisflows_system"]

        system.submit(workflow)

    def restart(self, **kwargs):
        """
        Restart simply means clean the workding dir and submit a new workflow.
        """
        self.clean()
        self.submit()

    def debug(self, **kwargs):
        """
        Initiate an IPython debugging environment to explore the currently
        active SeisFlows environment. Reloads the system modules in an
        interactive environment allowing exploration of the package space.
        Requires 'ipdb' and 'IPython'
        """
        self._register(precheck=False)
        self._load_modules()

        # Distribute modules to common names for easy access during debug mode
        PATH = sys.modules["seisflows_paths"]
        PAR = sys.modules["seisflows_parameters"]
        system = sys.modules["seisflows_system"]
        preprocess = sys.modules["seisflows_preprocess"]
        solver = sys.modules["seisflows_solver"]
        postprocess = sys.modules["seisflows_postprocess"]
        optimize = sys.modules["seisflows_optimize"]
        workflow = sys.modules["seisflows_workflow"]

        try:
            import ipdb
            from IPython import embed
        except ImportError as e:
            sys.exit("ipdb, IPython are required packages for debug mode, {e}")

        # > This is SeisFlows' debug mode.
        ipdb.set_trace(context=5)
        embed(colors="Neutral")
        # > Type 'n' to access a more useful IPython debugger environment.
        # > Type 'workflow.checkpoint()' to save any changes made here.

    def par(self, parameter, value=None, **kwargs):
        """
        Check or set parameters in the SeisFlows parameter file.

        USAGE

            seisflows par [parameter] [value]

            To check the parameter 'NPROC' from the command line:

                seisflows par nproc

            To set the parameter 'BEGIN' to 2:

                seisflows par begin 2

            To change the scratch path to the current working directory:

                seisflows par scratch ./

        :type parameter: str
        :param parameter: parameter to check in parameter file. case insensitive
        :type value: str
        :param value: value to set for parameter. if None, will simply print out
            the current parameter value. To set as Nonetype, set to 'null'
        """
        if parameter is None:
            self._subparser.print_help()
            sys.exit(0)

        # SeisFlows parameter file dictates upper-case parameters
        parameter = parameter.upper()

        if not os.path.exists(self._args.parameter_file):
            sys.exit(f"\n\tParameter file '{self._args.parameter_file}' "
                     f"does not exist\n")

        if value is not None and value.lower() == "none":
            warnings.warn("To set values to NoneType, use 'null' not 'None'",
                         UserWarning)

        with open(self._args.parameter_file, "r") as f:
            lines = f.readlines()

        for i, line in enumerate(lines):
            if f"{parameter}: " in line and "#" not in line:
                if value is not None:
                    # These values still have string formatters attached
                    current_par, current_val = line.split(":")

                    # This retains the string formatters of the line
                    new_val = current_val.replace(current_val.strip(), value)
                    lines[i] = ":".join([current_par, new_val])
                    print(f"\n\t{current_par.strip()}: "
                          f"{current_val.strip()} -> {value}\n")

                    with open(self._args.parameter_file, "w") as f:
                        f.writelines(lines)
                else:
                    print(f"\n\t{line}")
                break
        else:
            sys.exit(f"\n\t'{parameter}' not found in parameter file\n")

    def edit(self, name, module, editor=None, **kwargs):
        """
        Directly edit the SeisFlows source code matching the given name
        and module using the chosen text editor.

        USAGE

            seisflows edit [name] [module] [editor]

            To edit the base Solver class using vim, one would run:

                seisflows edit solver base vim

            To simply find the location of the inversion workflow source code:

                seisflows edit workflow inversion q

        :type name: str
        :param name: name of module, must match seisflows.config.NAMES
        :type module: str
        :param module: the module name contained under the SeisFlows namespace
        :type editor: str
        :param editor: optional chosen text editor to open the file.
            * If NoneType: defaults to system environment $EDITOR
            * If 'q': For quit, does not open an editor, simply prints fid
        """
        if name is None:
            self._subparser.print_help()
            sys.exit(0)

        editor = editor or os.environ.get("EDITOR")
        if editor is None:
            sys.exit("\n\t$EDITOR environment variable not set, set manually\n")

        REPO_DIR = os.path.abspath(os.path.join(ROOT_DIR, ".."))
        if name not in NAMES:
            sys.exit(f"\n\t{name} not in SeisFlows names: {NAMES}\n")

        for package in PACKAGES:
            fid_try = os.path.join(REPO_DIR, package, name, f"{module}.py")
            if os.path.exists(fid_try):
                if self._args.dont_open:
                    sys.exit(f"\n{fid_try}\n")
                else:
                    subprocess.call([editor, fid_try])
                    sys.exit(f"\n\tEdited file: {fid_try}\n")
        else:
            sys.exit(f"\n\tseisflows.{name}.{module} not found\n")

    def check(self, choice=None, **kwargs):
        """
        Check parameters, state or values  of an active SeisFlows environment.
        Type 'seisflows check --help' for a detailed help message.

        :type choice: str
        :param choice: underlying sub-function to choose
        """
        acceptable_args = {"model": self._check_model_parameters,
                           "iter": self._check_current_iteration,
                           "src": self._check_source_names,
                           "isrc": self._check_source_index}

        # Ensure that help message is thrown for empty commands
        if choice not in acceptable_args.keys():
            self._subparser.print_help()
            sys.exit(0)

        self._register(precheck=False)
        self._load_modules()
        acceptable_args[choice](*self._args.args, **kwargs)

    def reset(self, choice=None, **kwargs):
        """
        Mid-level function to wrap lower level reset functions
        """
        acceptable_args = {"line_search": self._reset_line_search,}

        # Ensure that help message is thrown for empty commands
        if choice not in acceptable_args.keys():
            self._subparser.print_help()
            sys.exit(0)

        self._register(precheck=False)
        self._load_modules()
        acceptable_args[choice](*self._args.args, **kwargs)

    def inspect(self, name=None, func=None, **kwargs):
        """
        Inspect inheritance hierarchy of classes, methods defined by SeisFlows.
        Useful when developing or debugging, facilitates identification of
        the package top-level.

        USAGE

            seisflows inspect [name] [method]

            To view overall hierarchy for all names in the SeisFlows namespace

                seisflows inspect

            To check the inheritance hierarchy of the 'workflow' module

                seisflows inspect workflow

            To check which class defined a given method, e.g. the 'eval_func'
            method attributed to the solver module

                seisflows inspect solver eval_func

        """
        self._register(precheck=False)
        self._load_modules()
        if func is None:
            self._inspect_module_hierarchy(name, **kwargs)
        else:
            self._inspect_class_that_defined_method(name, func, **kwargs)

    def convert(self, name, path=None, **kwargs):
        """
        Convert a model in the OUTPUT directory between vector to binary
        representation. Kwargs are passed through to solver.save()

        USAGE

            seisflows convert [name] [path] [**kwargs]

            To convert the vector model 'm_try' to binary representation in the
            output directory

                seisflows convert m_try

        :type name: str
        :param name: name of the model to convert, e.g. 'm_try'
        :type path: str
        :param path: path and file id to save the output model. if None, will
            default to saving in the output directory under the name of the
            model
        """
        self._load_modules(precheck=False)

        solver = sys.modules["seisflows_solver"]
        optimize = sys.modules["seisflows_optimize"]
        PATH = sys.modules["seisflows_paths"]

        if path is None:
            path = os.path.join(PATH.OUTPUT, name)
        if os.path.exists(path):
            sys.exit(f"\n\t{path} exists and this action would overwrite the "
                     f"existing path\n")

        solver.save(solver.split(optimize.load(name)), path=path, **kwargs )

    @staticmethod
    def _inspect_class_that_defined_method(name, func, **kwargs):
        """
        Given a function name and generalized module (e.g. solver), inspect
        which of the subclasses actually defined the function. Makes it easier
        to debug/edit source code as the user can quickly determine where
        in the source code they need to look to find the corresponding function.

        https://stackoverflow.com/questions/961048/get-class-that-defined-method

        :type name: str
        :param name: SeisFlows module name
        :type func: str
        :param func: Corresponding method/function name for the given module
        """
        # Dynamically get the correct module and function based on names
        try:
            module = sys.modules[f"seisflows_{name}"]
        except KeyError:
            sys.exit(f"\n\tSeisFlows has no module named '{name}'\n")
        try:
            method = getattr(module, func)
        except AttributeError:
            sys.exit(f"\n\tSeisFlows.{name} has no function '{func}'\n")

        method_name = method.__name__
        if method.__self__:
            classes = [method.__self__.__class__]
        else:
            # Deal with unbound method
            classes = [method.im_class]
        while classes:
            c = classes.pop()
            if method_name in c.__dict__:
                print(f"\n\t{c.__module__}.{c.__name__}.{func}\n")
                return
            else:
                classes = list(c.__bases__) + classes
        sys.exit(f"\n\tError matching class for SeisFlows.{name}.{func}\n")

    @staticmethod
    def _inspect_module_hierarchy(name=None, **kwargs):
        """
        Determine the order of class hierarchy for a given SeisFlows module.

        https://stackoverflow.com/questions/1401661/
                            list-all-base-classes-in-a-hierarchy-of-given-class

        :type name: str
        :param name: choice of module, if None, will print hierarchies for all
            modules.
        """
        for name_ in NAMES:
            if name and name_ != name:
                continue
            module = sys.modules[f"seisflows_{name_}"]
            print(f"\n\t{name_.upper()}", end=" ")
            for i, cls in enumerate(inspect.getmro(type(module))[::-1]):
                print(f"-> {cls.__name__}", end=" ")
        print("\n")

    def _reset_line_search(self, **kwargs):
        """
        Reset the machinery of the line search
        """
        optimize = sys.modules["seisflows_optimize"]
        workflow = sys.modules["seisflows_workflow"]
        
        current_step = optimize.line_search.step_count
        optimize.line_search.reset()
        new_step = optimize.line_search.step_count
    
        print(f"Step Count: {current_step} -> {new_step}")
        workflow.checkpoint()

    def _check_model_parameters(self, src=None, **kwargs):
        """
        Print out the min/max values from one or all of the currently available
        models. Useful for checking what models are associated with what part of
        the workflow, e.g. evaluate function, evaluate gradient.

        :type src: str
        :param src: the name of a specific model to check, e.g. 'm_try', 
            otherwise will check parameters for all models
        """
        import ipdb;ipdb.set_trace()

        optimize = sys.modules["seisflows_optimize"]
        PATH = sys.modules["seisflows_paths"]

        avail = glob(os.path.join(PATH.OPTIMIZE, "m_*"))
        srcs = [os.path.basename(_) for _ in avail]
        if src:
            if src not in srcs:
                sys.exit(f"\n\t{src} not in available models {avail}\n")
            srcs = [src]
        for tag in srcs:
            m = optimize.load(tag)
            optimize.check_model_parameters(m, tag)

    def _check_current_iteration(self, **kwargs):
        """
        Display the current point in the workflow in terms of the iteration
        and step count number. Args are not used by allow for a more general
        check() function.
        """
        optimize = sys.modules["seisflows_optimize"]
        try:
            line = optimize.line_search
            cstr = (f"\n"
                    f"\tIteration:  {optimize.iter}\n"
                    f"\tStep Count: {line.step_count} / {line.step_count_max}\n"
                    )
            print(cstr)
        except AttributeError:
            sys.exit("\n\toptimization module has not been initialized yet\n")

    def _check_source_names(self, source_name=None, **kwargs):
        """
        Sources are tagged by name but also by index in the source names which
        can be confusing and usually requires doubling checking. This check
        just prints out source names next to their respective index, or if a
        source name is requested, provides the index for that

        :type source_name: str
        :param source_name: name of source to check index, if None will simply
            print out all sources
        """     
        solver = sys.modules["seisflows_solver"]

        if source_name:
            print(f"{solver.source_names.index(source_name)}: {source_name}")
        else:
            for i, source_name in enumerate(solver.source_names):
                print(f"{i:>3}: {source_name}")

    def _check_source_index(self, idx=None, **kwargs):
        """
        Look up source name by index

        :type idx: int
        :param idx: index of source to look up
        """     
        solver = sys.modules["seisflows_solver"]
        print(f"\n\t{idx}: {solver.source_names[int(idx)]}\n")


def main():
    """
    Main entry point into the SeisFlows package is via the SeisFlows class
    """
    SeisFlows()

