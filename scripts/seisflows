#!/usr/bin/env python
"""
This script controls Seisflows.

This script needs to be run in a directory containing `parameters.yaml` which
should contain user defined paths and parameters to be used in the workflow
"""
import os
import sys
import argparse
import numpy as np

from seisflows.tools import unix, tools
from seisflows.config import config, tilde_expand, Dict, names
from seisflows.tools.tools import loadyaml


def get_args():
    """
    Get User defined arguments, or assign defaults

    :rtype: argparse.ArgumentParser()
    :return: User defined or default arguments
    """
    parser = argparse.ArgumentParser()

    # Required parameters
    parser.add_argument("-r", "--run", required=True, type=str,
                        choices=["submit", "clean", "resume", "debug",
                                 "restart"],
                        help="task for Seisflows to perform")

    # Default parameters
    parser.add_argument("-w", "--workdir", nargs="?", default=os.getcwd())
    parser.add_argument("-p", "--parameter_file", nargs="?",
                        default="parameters.yaml")

    return parser.parse_args()


def setup():
    """
    Common setup for multiple functions
    """
    args = get_args()

    # Check if the filepaths exist
    if not os.path.exists(args.parameter_file):
        raise Exception(f"Parameter file not found: {args.parameter_file}")

    # Register parameters
    parameters = loadyaml(args.parameter_file)
    sys.modules['seisflows_parameters'] = Dict(parameters)

    # Register paths, they should have been checked by submit
    paths = tilde_expand(parameters['PATHS'])
    sys.modules['seisflows_paths'] = Dict(paths)

    return args, paths, parameters


def submit():
    """
    Submit the workflow for the first time
    """
    args, paths, parameters = setup()

    # Check that paths exist
    paths_dont_exist = []
    for key, path in paths.items():
        if (key in ["OUTPUT", "SCRATCH", "PYATOA_IO"]) or (path == ""):
            continue
        if not os.path.exists(path):
            paths_dont_exist.append(path)
    if paths_dont_exist:
        print("The following paths do not exist:")
        for path_ in paths_dont_exist:
            print(f"\t{path_}")
        sys.exit()

    # If paths exist, pass to modules
    sys.modules["seisflows_paths"] = Dict(paths)
    unix.mkdir(args.workdir)
    unix.cd(args.workdir)

    # Submit workflow
    config()
    workflow = sys.modules["seisflows_workflow"]
    system = sys.modules["seisflows_system"]

    system.submit(workflow)


def resume(debug=False):
    """
    Resume a previously started workflow

    :type debug: bool
    :param debug: Do not submit the workflow, but rather open a debugger so the
        User can search and step through the workflow
    """
    args, paths, parameters = setup()

    # Register parameters
    parameters = loadyaml(args.parameter_file)
    sys.modules["seisflows_parameters"] = Dict(parameters)

    # Register paths, they should have been checked by submit
    paths = tilde_expand(parameters["PATHS"])
    sys.modules["seisflows_paths"] = Dict(paths)

    # Create the necessary paths
    unix.mkdir(args.workdir)
    unix.cd(args.workdir)

    # Reload objects from Pickle files
    for name in names:
        fullfile = os.path.join(args.workdir, "output", f"seisflows_{name}.p")
        sys.modules[f"seisflows_{name}"] = tools.loadobj(fullfile)

    # Check parameters
    for name in names:
        sys.modules[f"seisflows_{name}"].check()

    workflow = sys.modules["seisflows_workflow"]
    system = sys.modules["seisflows_system"]

    if debug:
        # Prematurely distribute modules for easier debugging
        PATH = sys.modules["seisflows_paths"]
        PAR = sys.modules["seisflows_parameters"]

        solver = sys.modules["seisflows_solver"]
        optimize = sys.modules["seisflows_optimize"]
        postprocess = sys.modules["seisflows_postprocess"]

        import ipdb; ipdb.set_trace()
    else:
        system.submit(workflow)


def clean(workdir):
    """
    Clean the working directory

    :type workdir: str
    :param workdir: working directory to clean
    """
    check = input("Are you sure you want to clean, this will remove all current"
                  "\nworkflow objects, leaving only the parameter file (y/[n])")
    if check == "y":
        unix.rm(os.path.join(workdir, "output*"))
        unix.rm(os.path.join(workdir, "error.log"))
        unix.rm(os.path.join(workdir, "scratch"))
        unix.rm(os.path.join(workdir, "pyatoa.io"))


def convert_model(solver, path_output, model_fid):
    """
    convert model .npy to .bin files

    TODO:
        figure out where to put this in seisflows

    :type solver: module
    :param solver: seisflows.solver
    :type path_output: str
    :param path_output: path to the 'output' directory where models are saved
    :type model_fid: str
    :param model_fid: the model that should be converted
    """
    src = os.path.join(path_output, f"{model_fid}.npy")
    dst = os.path.join(path_output, model_fid)

    if not os.path.exists(src):
        print(f"{src} does not exist")
        return
    elif os.path.exists(dst):
        print(f"{src} already exists")
        return

    solver.save(solver.split(np.load(src)), dst)


if __name__ == "__main__":
    args_ = get_args()
    if args_.run == "submit":
        submit()
    elif args_.run == "resume":
        resume(debug=False)
    elif args_.run == "debug":
        resume(debug=True)
    elif args_.run == "clean":
        clean(args_.workdir)
    elif args_.run == "restart":
        clean(args_.workdir)
        submit()
